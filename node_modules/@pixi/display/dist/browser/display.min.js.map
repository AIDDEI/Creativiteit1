{"version":3,"file":"display.min.js","sources":["../../src/settings.ts","../../src/Bounds.ts","../../../../node_modules/tslib/tslib.es6.js","../../src/DisplayObject.ts","../../src/Container.ts"],"sourcesContent":["import { settings } from '@pixi/settings';\n\n/**\n * Sets the default value for the container property 'sortableChildren'.\n * If set to true, the container will sort its children by zIndex value\n * when updateTransform() is called, or manually if sortChildren() is called.\n *\n * This actually changes the order of elements in the array, so should be treated\n * as a basic solution that is not performant compared to other solutions,\n * such as @link https://github.com/pixijs/pixi-display\n *\n * Also be aware of that this may not work nicely with the addChildAt() function,\n * as the zIndex sorting may cause the child to automatically sorted to another position.\n *\n * @static\n * @constant\n * @name SORTABLE_CHILDREN\n * @memberof PIXI.settings\n * @type {boolean}\n * @default false\n */\nsettings.SORTABLE_CHILDREN = false;\n\nexport { settings };\n","import { Rectangle } from '@pixi/math';\n\nimport type { IPointData, Transform, Matrix } from '@pixi/math';\n\n/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n *\n * @memberof PIXI\n */\nexport class Bounds\n{\n    /** @default Infinity */\n    public minX: number;\n\n    /** @default Infinity */\n    public minY: number;\n\n    /** @default -Infinity */\n    public maxX: number;\n\n    /** @default -Infinity */\n    public maxY: number;\n\n    public rect: Rectangle;\n\n    /**\n     * It is updated to _boundsID of corresponding object to keep bounds in sync with content.\n     * Updated from outside, thus public modifier.\n     */\n    public updateID: number;\n\n    constructor()\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.rect = null;\n        this.updateID = -1;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     *\n     * @return - True if empty.\n     */\n    isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /** Clears the bounds and resets. */\n    clear(): void\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n    }\n\n    /**\n     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n     * It is not guaranteed that it will return tempRect\n     *\n     * @param rect - Temporary object will be used if AABB is not empty\n     * @returns - A rectangle of the bounds\n     */\n    getRectangle(rect?: Rectangle): Rectangle\n    {\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            return Rectangle.EMPTY;\n        }\n\n        rect = rect || new Rectangle(0, 0, 1, 1);\n\n        rect.x = this.minX;\n        rect.y = this.minY;\n        rect.width = this.maxX - this.minX;\n        rect.height = this.maxY - this.minY;\n\n        return rect;\n    }\n\n    /**\n     * This function should be inlined when its possible.\n     *\n     * @param point - The point to add.\n     */\n    addPoint(point: IPointData): void\n    {\n        this.minX = Math.min(this.minX, point.x);\n        this.maxX = Math.max(this.maxX, point.x);\n        this.minY = Math.min(this.minY, point.y);\n        this.maxY = Math.max(this.maxY, point.y);\n    }\n\n    /** Adds a point, after transformed. This should be inlined when its possible. */\n    addPointMatrix(matrix: Matrix, point: IPointData): void\n    {\n        const { a, b, c, d, tx, ty } = matrix;\n\n        const x = (a * point.x) + (c * point.y) + tx;\n        const y = (b * point.x) + (d * point.y) + ty;\n\n        this.minX = Math.min(this.minX, x);\n        this.maxX = Math.max(this.maxX, x);\n        this.minY = Math.min(this.minY, y);\n        this.maxY = Math.max(this.maxY, y);\n    }\n\n    /**\n     * Adds a quad, not transformed\n     *\n     * @param vertices - The verts to add.\n     */\n    addQuad(vertices: Float32Array): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = vertices[0];\n        let y = vertices[1];\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[2];\n        y = vertices[3];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[4];\n        y = vertices[5];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[6];\n        y = vertices[7];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds sprite frame, transformed.\n     *\n     * @param transform - transform to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    addFrame(transform: Transform, x0: number, y0: number, x1: number, y1: number): void\n    {\n        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n    }\n\n    /**\n     * Adds sprite frame, multiplied by matrix\n     *\n     * @param matrix - matrix to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    addFrameMatrix(matrix: Matrix, x0: number, y0: number, x1: number, y1: number): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds screen vertices from array\n     *\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */\n    addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const x = vertexData[i];\n            const y = vertexData[i + 1];\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Add an array of mesh vertices\n     *\n     * @param transform - mesh transform\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */\n    addVertices(transform: Transform, vertices: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n    }\n\n    /**\n     * Add an array of mesh vertices.\n     *\n     * @param matrix - mesh matrix\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param padX - x padding\n     * @param padY - y padding\n     */\n    addVerticesMatrix(matrix: Matrix, vertices: Float32Array, beginOffset: number,\n        endOffset: number, padX = 0, padY = padX): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const rawX = vertices[i];\n            const rawY = vertices[i + 1];\n            const x = (a * rawX) + (c * rawY) + tx;\n            const y = (d * rawY) + (b * rawX) + ty;\n\n            minX = Math.min(minX, x - padX);\n            maxX = Math.max(maxX, x + padX);\n            minY = Math.min(minY, y - padY);\n            maxY = Math.max(maxY, y + padY);\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds other {@link Bounds}.\n     *\n     * @param bounds - The Bounds to be added\n     */\n    addBounds(bounds: Bounds): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        this.minX = bounds.minX < minX ? bounds.minX : minX;\n        this.minY = bounds.minY < minY ? bounds.minY : minY;\n        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     *\n     * @param bounds - The Bounds to be added.\n     * @param mask - TODO\n     */\n    addBoundsMask(bounds: Bounds, mask: Bounds): void\n    {\n        const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n        const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n        const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n        const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.\n     *\n     * @param bounds - other bounds\n     * @param matrix - multiplicator\n     */\n    addBoundsMatrix(bounds: Bounds, matrix: Matrix): void\n    {\n        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n    }\n\n    /**\n     * Adds other Bounds, masked with Rectangle.\n     *\n     * @param bounds - TODO\n     * @param area - TODO\n     */\n    addBoundsArea(bounds: Bounds, area: Rectangle): void\n    {\n        const _minX = bounds.minX > area.x ? bounds.minX : area.x;\n        const _minY = bounds.minY > area.y ? bounds.minY : area.y;\n        const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);\n        const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     *\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */\n    pad(paddingX = 0, paddingY = paddingX): void\n    {\n        if (!this.isEmpty())\n        {\n            this.minX -= paddingX;\n            this.maxX += paddingX;\n            this.minY -= paddingY;\n            this.maxY += paddingY;\n        }\n    }\n\n    /**\n     * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n     *\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param padX - padding X\n     * @param padY - padding Y\n     */\n    addFramePad(x0: number, y0: number, x1: number, y1: number, padX: number, padY: number): void\n    {\n        x0 -= padX;\n        y0 -= padY;\n        x1 += padX;\n        y1 += padY;\n\n        this.minX = this.minX < x0 ? this.minX : x0;\n        this.maxX = this.maxX > x1 ? this.maxX : x1;\n        this.minY = this.minY < y0 ? this.minY : y0;\n        this.maxY = this.maxY > y1 ? this.maxY : y1;\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { DEG_TO_RAD, Matrix, Point, RAD_TO_DEG, Rectangle, Transform } from '@pixi/math';\nimport { EventEmitter } from '@pixi/utils';\nimport { Bounds } from './Bounds';\n\nimport type { Container } from './Container';\nimport type { Filter, MaskData, Renderer } from '@pixi/core';\nimport type { IPointData, ObservablePoint } from '@pixi/math';\nimport type { Dict } from '@pixi/utils';\n\nexport interface IDestroyOptions {\n    children?: boolean;\n    texture?: boolean;\n    baseTexture?: boolean;\n}\n\nexport interface DisplayObject extends Omit<GlobalMixins.DisplayObject, keyof EventEmitter>, EventEmitter {}\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and can not be used on its own; rather it should be extended.\n *\n * ## Display objects implemented in PixiJS\n *\n * | Display Object                  | Description                                                           |\n * | ------------------------------- | --------------------------------------------------------------------- |\n * | {@link PIXI.Container}          | Adds support for `children` to DisplayObject                          |\n * | {@link PIXI.Graphics}           | Shape-drawing display object similar to the Canvas API                |\n * | {@link PIXI.Sprite}             | Draws textures (i.e. images)                                          |\n * | {@link PIXI.Text}               | Draws text using the Canvas API internally                            |\n * | {@link PIXI.BitmapText}         | More scaleable solution for text rendering, reusing glyph textures    |\n * | {@link PIXI.TilingSprite}       | Draws textures/images in a tiled fashion                              |\n * | {@link PIXI.AnimatedSprite}     | Draws an animation of multiple images                                 |\n * | {@link PIXI.Mesh}               | Provides a lower-level API for drawing meshes with custom data        |\n * | {@link PIXI.NineSlicePlane}     | Mesh-related                                                          |\n * | {@link PIXI.SimpleMesh}         | v4-compatible mesh                                                    |\n * | {@link PIXI.SimplePlane}        | Mesh-related                                                          |\n * | {@link PIXI.SimpleRope}         | Mesh-related                                                          |\n *\n * ## Transforms\n *\n * The [transform]{@link DisplayObject#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link PIXI.DisplayObject#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link PIXI.DisplayObject#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link PIXI.DisplayObject#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link PIXI.DisplayObject#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link PIXI.DisplayObject#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link PIXI.DisplayObject#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link PIXI.DisplayObject#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are communtative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>angle</td>\n *       <td>Rotation. This is an alias for [rotation]{@link PIXI.DisplayObject#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>x</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>y</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>width</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>height</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n *\n * ## Bounds\n *\n * The bounds of a display object is defined by the minimum axis-aligned rectangle in world space that can fit\n * around it. The abstract `calculateBounds` method is responsible for providing it (and it should use the\n * `worldTransform` to calculate in world space).\n *\n * There are a few additional types of bounding boxes:\n *\n * | Bounds                | Description                                                                              |\n * | --------------------- | ---------------------------------------------------------------------------------------- |\n * | World Bounds          | This is synonymous is the regular bounds described above. See `getBounds()`.             |\n * | Local Bounds          | This the axis-aligned bounding box in the parent's local space. See `getLocalBounds()`.  |\n * | Render Bounds         | The bounds, but including extra rendering effects like filter padding.                   |\n * | Projected Bounds      | The bounds of the projected display object onto the screen. Usually equals world bounds. |\n * | Relative Bounds       | The bounds of a display object when projected onto a ancestor's (or parent's) space.     |\n * | Natural Bounds        | The bounds of an object in its own local space (not parent's space, like in local bounds)|\n * | Content Bounds        | The natural bounds when excluding all children of a `Container`.                         |\n *\n * ### calculateBounds\n *\n * [Container]{@link Container} already implements `calculateBounds` in a manner that includes children.\n *\n * But for a non-Container display object, the `calculateBounds` method must be overridden in order for `getBounds` and\n * `getLocalBounds` to work. This method must write the bounds into `this._bounds`.\n *\n * Generally, the following technique works for most simple cases: take the list of points\n * forming the \"hull\" of the object (i.e. outline of the object's shape), and then add them\n * using {@link PIXI.Bounds#addPointMatrix}.\n *\n * ```js\n * calculateBounds(): void\n * {\n *     const points = [...];\n *\n *     for (let i = 0, j = points.length; i < j; i++)\n *     {\n *         this._bounds.addPointMatrix(this.worldTransform, points[i]);\n *     }\n * }\n * ```\n *\n * You can optimize this for a large number of points by using {@link PIXI.Bounds#addVerticesMatrix} to pass them\n * in one array together.\n *\n * ## Alpha\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n *\n * The alpha with which the display object will be rendered is called the [worldAlpha]{@link PIXI.DisplayObject#worldAlpha}.\n *\n * ## Renderable vs Visible\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n *\n * It is recommended that applications use the `renderable` property for culling. See\n * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} or\n * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull} for more details.\n *\n * Otherwise, to prevent an object from rendering in the general-purpose sense - `visible` is the property to use. This\n * one is also better in terms of performance.\n *\n * @memberof PIXI\n */\nexport abstract class DisplayObject extends EventEmitter\n{\n    abstract sortDirty: boolean;\n\n    /** The display object container that contains this display object. */\n    public parent: Container;\n\n    /**\n     * The multiplied alpha of the displayObject.\n     *\n     * @readonly\n     */\n    public worldAlpha: number;\n\n    /**\n     * World transform and local transform of this object.\n     * This will become read-only later, please do not assign anything there unless you know what are you doing.\n     */\n    public transform: Transform;\n\n    /** The opacity of the object. */\n    public alpha: number;\n\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\n     */\n    public visible: boolean;\n\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds manually.\n     */\n    public renderable: boolean;\n\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     */\n    public cullable: boolean;\n\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     */\n    public cullArea: Rectangle;\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     */\n    public filterArea: Rectangle;\n\n    /**\n     * Sets the filters for the displayObject.\n     * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     */\n    public filters: Filter[] | null;\n\n    /** Used to fast check if a sprite is.. a sprite! */\n    public isSprite: boolean;\n\n    /** Does any other displayObject use this object as a mask? */\n    public isMask: boolean;\n\n    /**\n     * Which index in the children array the display component was before the previous zIndex sort.\n     * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\n     *\n     * @protected\n     */\n    public _lastSortedIndex: number;\n\n    /**\n     * The original, cached mask of the object.\n     *\n     * @protected\n     */\n    public _mask: Container|MaskData;\n\n    /** The bounds object, this is used to calculate and store the bounds of the displayObject. */\n    public _bounds: Bounds;\n\n    /** Local bounds object, swapped with `_bounds` when using `getLocalBounds()`. */\n    public _localBounds: Bounds;\n\n    /**\n     * The zIndex of the displayObject.\n     * A higher value will mean it will be rendered on top of other displayObjects within the same container.\n     *\n     * @protected\n     */\n    protected _zIndex: number;\n\n    /**\n     * Currently enabled filters.\n     *\n     * @protected\n     */\n    protected _enabledFilters: Filter[];\n\n    /** Flags the cached bounds as dirty. */\n    protected _boundsID: number;\n\n    /** Cache of this display-object's bounds-rectangle. */\n    protected _boundsRect: Rectangle;\n\n    /** Cache of this display-object's local-bounds rectangle. */\n    protected _localBoundsRect: Rectangle;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    protected _destroyed: boolean;\n\n    /**\n     * The number of times this object is used as a mask by another object. */\n    private _maskRefCount: number;\n    private tempDisplayObjectParent: TemporaryDisplayObject;\n    public displayObjectUpdateTransform: () => void;\n\n    /**\n     * Mixes all enumerable properties and methods from a source object to DisplayObject.\n     *\n     * @param source - The source of properties and methods to mix in.\n     */\n    static mixin(source: Dict<any>): void\n    {\n        // in ES8/ES2017, this would be really easy:\n        // Object.defineProperties(DisplayObject.prototype, Object.getOwnPropertyDescriptors(source));\n\n        // get all the enumerable property keys\n        const keys = Object.keys(source);\n\n        // loop through properties\n        for (let i = 0; i < keys.length; ++i)\n        {\n            const propertyName = keys[i];\n\n            // Set the property using the property descriptor - this works for accessors and normal value properties\n            Object.defineProperty(\n                DisplayObject.prototype,\n                propertyName,\n                Object.getOwnPropertyDescriptor(source, propertyName)\n            );\n        }\n    }\n\n    constructor()\n    {\n        super();\n\n        this.tempDisplayObjectParent = null;\n\n        // TODO: need to create Transform from factory\n        this.transform = new Transform();\n        this.alpha = 1;\n        this.visible = true;\n        this.renderable = true;\n        this.cullable = false;\n        this.cullArea = null;\n\n        this.parent = null;\n        this.worldAlpha = 1;\n\n        this._lastSortedIndex = 0;\n        this._zIndex = 0;\n\n        this.filterArea = null;\n        this.filters = null;\n        this._enabledFilters = null;\n\n        this._bounds = new Bounds();\n        this._localBounds = null;\n        this._boundsID = 0;\n        this._boundsRect = null;\n        this._localBoundsRect = null;\n        this._mask = null;\n        this._maskRefCount = 0;\n        this._destroyed = false;\n\n        this.isSprite = false;\n        this.isMask = false;\n    }\n\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     *\n     * @instance\n     * @event added\n     * @param {PIXI.Container} container - The container added to.\n     */\n\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     *\n     * @instance\n     * @event removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n\n    /**\n     * Fired when this DisplayObject is destroyed.\n     *\n     * @instance\n     * @event destroyed\n     */\n\n    /** Readonly flag for destroyed display objects. */\n    get destroyed(): boolean\n    {\n        return this._destroyed;\n    }\n\n    /** Recalculates the bounds of the display object. */\n    abstract calculateBounds(): void;\n\n    abstract removeChild(child: DisplayObject): void;\n\n    /**\n     * Renders the object using the WebGL renderer.\n     *\n     * @param renderer - The renderer.\n     */\n    abstract render(renderer: Renderer): void;\n\n    /**\n     * Recursively updates transform of all objects from the root to this one\n     * internal function for toLocal()\n     */\n    protected _recursivePostUpdateTransform(): void\n    {\n        if (this.parent)\n        {\n            this.parent._recursivePostUpdateTransform();\n            this.transform.updateTransform(this.parent.transform);\n        }\n        else\n        {\n            this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n        }\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     *\n     * TODO - Optimization pass!\n     */\n    updateTransform(): void\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n        // multiply the alphas..\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.\n     *\n     * This method is expensive on containers with a large subtree (like the stage). This is because the bounds\n     * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to\n     * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update\n     * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using\n     * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,\n     * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as\n     * its height increases.\n     *\n     * * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.\n     * * The world bounds of all display objects in a container's **subtree** will also be recalculated.\n     *\n     * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds\n     * calculation if needed.\n     *\n     * ```js\n     * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);\n     * ```\n     *\n     * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This\n     * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more\n     * details.\n     *\n     * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms\n     * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain\n     * cases.\n     *\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @return - The minimum axis-aligned rectangle in world space that fits around this object.\n     */\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        if (!skipUpdate)\n        {\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.updateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this._recursivePostUpdateTransform();\n                this.updateTransform();\n            }\n        }\n\n        if (this._bounds.updateID !== this._boundsID)\n        {\n            this.calculateBounds();\n            this._bounds.updateID = this._boundsID;\n        }\n\n        if (!rect)\n        {\n            if (!this._boundsRect)\n            {\n                this._boundsRect = new Rectangle();\n            }\n\n            rect = this._boundsRect;\n        }\n\n        return this._bounds.getRectangle(rect);\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     *\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @return - The rectangular bounding area.\n     */\n    getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        if (!rect)\n        {\n            if (!this._localBoundsRect)\n            {\n                this._localBoundsRect = new Rectangle();\n            }\n\n            rect = this._localBoundsRect;\n        }\n\n        if (!this._localBounds)\n        {\n            this._localBounds = new Bounds();\n        }\n\n        const transformRef = this.transform;\n        const parentRef = this.parent;\n\n        this.parent = null;\n        this.transform = this._tempDisplayObjectParent.transform;\n\n        const worldBounds = this._bounds;\n        const worldBoundsID = this._boundsID;\n\n        this._bounds = this._localBounds;\n\n        const bounds = this.getBounds(false, rect);\n\n        this.parent = parentRef;\n        this.transform = transformRef;\n\n        this._bounds = worldBounds;\n        this._bounds.updateID += this._boundsID - worldBoundsID;// reflect side-effects\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the global position of the display object.\n     *\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @return - A point object representing the position of this object.\n     */\n    toGlobal<P extends IPointData = Point>(position: IPointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // don't need to update the lot\n        return this.worldTransform.apply<P>(position, point);\n    }\n\n    /**\n     * Calculates the local position of the display object relative to another point.\n     *\n     * @param position - The world origin to calculate from.\n     * @param from - The DisplayObject to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @return - A point object representing the position of this object\n     */\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n\n    /**\n     * Set the parent Container of this DisplayObject.\n     *\n     * @param container - The Container to add this DisplayObject to.\n     * @return - The Container that this DisplayObject was added to.\n     */\n    setParent(container: Container): Container\n    {\n        if (!container || !container.addChild)\n        {\n            throw new Error('setParent: Argument must be a Container');\n        }\n\n        container.addChild(this);\n\n        return container;\n    }\n\n    /**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     *\n     * @param x - The X position\n     * @param y - The Y position\n     * @param scaleX - The X scale value\n     * @param scaleY - The Y scale value\n     * @param rotation - The rotation\n     * @param skewX - The X skew value\n     * @param skewY - The Y skew value\n     * @param pivotX - The X pivot value\n     * @param pivotY - The Y pivot value\n     * @return - The DisplayObject instance\n     */\n    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0): this\n    {\n        this.position.x = x;\n        this.position.y = y;\n        this.scale.x = !scaleX ? 1 : scaleX;\n        this.scale.y = !scaleY ? 1 : scaleY;\n        this.rotation = rotation;\n        this.skew.x = skewX;\n        this.skew.y = skewY;\n        this.pivot.x = pivotX;\n        this.pivot.y = pivotY;\n\n        return this;\n    }\n\n    /**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy()`.\n     */\n    destroy(_options?: IDestroyOptions|boolean): void\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this.emit('destroyed');\n        this.removeAllListeners();\n        this.transform = null;\n\n        this.parent = null;\n        this._bounds = null;\n        this.mask = null;\n\n        this.cullArea = null;\n        this.filters = null;\n        this.filterArea = null;\n        this.hitArea = null;\n\n        this.interactive = false;\n        this.interactiveChildren = false;\n\n        this._destroyed = true;\n    }\n\n    /**\n     * @protected\n     * @member {PIXI.Container}\n     */\n    get _tempDisplayObjectParent(): TemporaryDisplayObject\n    {\n        if (this.tempDisplayObjectParent === null)\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            this.tempDisplayObjectParent = new TemporaryDisplayObject();\n        }\n\n        return this.tempDisplayObjectParent;\n    }\n\n    /**\n     * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root\n     *\n     * ```\n     * const cacheParent = elem.enableTempParent();\n     * elem.updateTransform();\n     * elem.disableTempParent(cacheParent);\n     * ```\n     *\n     * @returns - current parent\n     */\n    enableTempParent(): Container\n    {\n        const myParent = this.parent;\n\n        this.parent = this._tempDisplayObjectParent as Container;\n\n        return myParent;\n    }\n\n    /**\n     * Pair method for `enableTempParent`\n     *\n     * @param cacheParent - Actual parent of element\n     */\n    disableTempParent(cacheParent: Container): void\n    {\n        this.parent = cacheParent;\n    }\n\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this.position.x;\n    }\n\n    set x(value: number)\n    {\n        this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this.position.y;\n    }\n\n    set y(value: number)\n    {\n        this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     *\n     * @readonly\n     */\n    get worldTransform(): Matrix\n    {\n        return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     *\n     * @readonly\n     */\n    get localTransform(): Matrix\n    {\n        return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     *\n     * @since PixiJS 4\n     */\n    get position(): ObservablePoint\n    {\n        return this.transform.position;\n    }\n\n    set position(value: ObservablePoint)\n    {\n        this.transform.position.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     *\n     * @since PixiJS 4\n     */\n    get scale(): ObservablePoint\n    {\n        return this.transform.scale;\n    }\n\n    set scale(value: ObservablePoint)\n    {\n        this.transform.scale.copyFrom(value);\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     *\n     * @since PixiJS 4\n     */\n    get pivot(): ObservablePoint\n    {\n        return this.transform.pivot;\n    }\n\n    set pivot(value: ObservablePoint)\n    {\n        this.transform.pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     *\n     * @since PixiJS 4\n     */\n    get skew(): ObservablePoint\n    {\n        return this.transform.skew;\n    }\n\n    set skew(value: ObservablePoint)\n    {\n        this.transform.skew.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this.transform.rotation;\n    }\n\n    set rotation(value: number)\n    {\n        this.transform.rotation = value;\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.transform.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.transform.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The zIndex of the displayObject.\n     *\n     * If a container has the sortableChildren property set to true, children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     *\n     * @see PIXI.Container#sortableChildren\n     */\n    get zIndex(): number\n    {\n        return this._zIndex;\n    }\n\n    set zIndex(value: number)\n    {\n        this._zIndex = value;\n        if (this.parent)\n        {\n            this.parent.sortDirty = true;\n        }\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     *\n     * @readonly\n     */\n    get worldVisible(): boolean\n    {\n        let item = this as DisplayObject;\n\n        do\n        {\n            if (!item.visible)\n            {\n                return false;\n            }\n\n            item = item.parent;\n        } while (item);\n\n        return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     *\n     * @example\n     * const graphics = new PIXI.Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.mask = graphics;\n     *\n     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     */\n    get mask(): Container|MaskData|null\n    {\n        return this._mask;\n    }\n\n    set mask(value: Container|MaskData|null)\n    {\n        if (this._mask === value)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).maskObject || this._mask) as Container;\n\n            maskObject._maskRefCount--;\n\n            if (maskObject._maskRefCount === 0)\n            {\n                maskObject.renderable = true;\n                maskObject.isMask = false;\n            }\n        }\n\n        this._mask = value;\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).maskObject || this._mask) as Container;\n\n            if (maskObject._maskRefCount === 0)\n            {\n                maskObject.renderable = false;\n                maskObject.isMask = true;\n            }\n\n            maskObject._maskRefCount++;\n        }\n    }\n}\n\n/**\n * @private\n */\nexport class TemporaryDisplayObject extends DisplayObject\n{\n    calculateBounds: () => null;\n    removeChild: (child: DisplayObject) => null;\n    render: (renderer: Renderer) => null;\n    sortDirty: boolean = null;\n}\n\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.DisplayObject#\n * @method displayObjectUpdateTransform\n */\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n","import { settings } from '@pixi/settings';\nimport { removeItems } from '@pixi/utils';\nimport { DisplayObject } from './DisplayObject';\nimport { Matrix, Rectangle } from '@pixi/math';\nimport { MASK_TYPES } from '@pixi/constants';\n\nimport type { MaskData, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from './DisplayObject';\n\nfunction sortChildren(a: DisplayObject, b: DisplayObject): number\n{\n    if (a.zIndex === b.zIndex)\n    {\n        return a._lastSortedIndex - b._lastSortedIndex;\n    }\n\n    return a.zIndex - b.zIndex;\n}\n\nexport interface Container extends GlobalMixins.Container, DisplayObject {}\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * ```js\n * import { BlurFilter } from '@pixi/filter-blur';\n * import { Container } from '@pixi/display';\n * import { Graphics } from '@pixi/graphics';\n * import { Sprite } from '@pixi/sprite';\n *\n * let container = new Container();\n * let sprite = Sprite.from(\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png\");\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *  .beginFill(0xffffff)\n *  .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *  .endFill();\n * ```\n *\n * @memberof PIXI\n */\nexport class Container extends DisplayObject\n{\n    /**\n     * The array of children of this container.\n     *\n     * @readonly\n     */\n    public readonly children: DisplayObject[];\n\n    /**\n     * If set to true, the container will sort its children by zIndex value\n     * when updateTransform() is called, or manually if sortChildren() is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as @link https://github.com/pixijs/pixi-display\n     *\n     * Also be aware of that this may not work nicely with the addChildAt() function,\n     * as the zIndex sorting may cause the child to automatically sorted to another position.\n     *\n     * @see PIXI.settings.SORTABLE_CHILDREN\n     */\n    public sortableChildren: boolean;\n\n    /**\n     * Should children be sorted by zIndex at the next updateTransform call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     */\n    public sortDirty: boolean;\n    public parent: Container;\n    public containerUpdateTransform: () => void;\n\n    protected _width: number;\n    protected _height: number;\n\n    constructor()\n    {\n        super();\n\n        this.children = [];\n        this.sortableChildren = settings.SORTABLE_CHILDREN;\n        this.sortDirty = false;\n\n        /**\n         * Fired when a DisplayObject is added to this Container.\n         *\n         * @event PIXI.Container#childAdded\n         * @param {PIXI.DisplayObject} child - The child added to the Container.\n         * @param {PIXI.Container} container - The container that added the child.\n         * @param {number} index - The children's index of the added child.\n         */\n\n        /**\n         * Fired when a DisplayObject is removed from this Container.\n         *\n         * @event PIXI.DisplayObject#removedFrom\n         * @param {PIXI.DisplayObject} child - The child removed from the Container.\n         * @param {PIXI.Container} container - The container that removed removed the child.\n         * @param {number} index - The former children's index of the removed child\n         */\n    }\n\n    /** Overridable method that can be used by Container subclasses whenever the children array is modified. */\n    protected onChildrenChange(_length?: number): void\n    {\n        /* empty */\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     *\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container\n     * @return {PIXI.DisplayObject} - The first child that was added.\n     */\n    addChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                // eslint-disable-next-line prefer-rest-params\n                this.addChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0];\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            this.sortDirty = true;\n\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            this.children.push(child);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(this.children.length - 1);\n            this.emit('childAdded', child, this, this.children.length - 1);\n            child.emit('added', this);\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n     *\n     * @param {PIXI.DisplayObject} child - The child to add\n     * @param {number} index - The index to place the child in\n     * @return {PIXI.DisplayObject} The child that was added.\n     */\n    addChildAt<T extends DisplayObject>(child: T, index: number): T\n    {\n        if (index < 0 || index > this.children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        this.children.splice(index, 0, child);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n        this.emit('childAdded', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Swaps the position of 2 Display Objects within this container.\n     *\n     * @param child - First display object to swap\n     * @param child2 - Second display object to swap\n     */\n    swapChildren(child: DisplayObject, child2: DisplayObject): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        this.onChildrenChange(index1 < index2 ? index1 : index2);\n    }\n\n    /**\n     * Returns the index position of a child DisplayObject instance\n     *\n     * @param child - The DisplayObject instance to identify\n     * @return - The index position of the child display object to identify\n     */\n    getChildIndex(child: DisplayObject): number\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    /**\n     * Changes the position of an existing child in the display object container\n     *\n     * @param child - The child DisplayObject instance for which you want to change the index number\n     * @param index - The resulting index number for the child display object\n     */\n    setChildIndex(child: DisplayObject, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        const currentIndex = this.getChildIndex(child);\n\n        removeItems(this.children, currentIndex, 1); // remove from old position\n        this.children.splice(index, 0, child); // add at new position\n\n        this.onChildrenChange(index);\n    }\n\n    /**\n     * Returns the child at the specified index\n     *\n     * @param index - The index to get the child at\n     * @return - The child at the given index, if any.\n     */\n    getChildAt(index: number): DisplayObject\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index];\n    }\n\n    /**\n     * Removes one or more children from the container.\n     *\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove\n     * @return {PIXI.DisplayObject} The first child that was removed.\n     */\n    removeChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0];\n            const index = this.children.indexOf(child);\n\n            if (index === -1) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n            removeItems(this.children, index, 1);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(index);\n            child.emit('removed', this);\n            this.emit('childRemoved', child, this, index);\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Removes a child from the specified index position.\n     *\n     * @param index - The index to get the child from\n     * @return The child that was removed.\n     */\n    removeChildAt(index: number): DisplayObject\n    {\n        const child = this.getChildAt(index);\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        removeItems(this.children, index, 1);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n        this.emit('childRemoved', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     *\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed children\n     */\n    removeChildren(beginIndex = 0, endIndex = this.children.length): DisplayObject[]\n    {\n        const begin = beginIndex;\n        const end = endIndex;\n        const range = end - begin;\n        let removed;\n\n        if (range > 0 && range <= end)\n        {\n            removed = this.children.splice(begin, range);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n                this.emit('childRemoved', removed[i], this, i);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /** Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex. */\n    sortChildren(): void\n    {\n        let sortRequired = false;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            child._lastSortedIndex = i;\n\n            if (!sortRequired && child.zIndex !== 0)\n            {\n                sortRequired = true;\n            }\n        }\n\n        if (sortRequired && this.children.length > 1)\n        {\n            this.children.sort(sortChildren);\n        }\n\n        this.sortDirty = false;\n    }\n\n    /** Updates the transform on all children of this container for rendering. */\n    updateTransform(): void\n    {\n        if (this.sortableChildren && this.sortDirty)\n        {\n            this.sortChildren();\n        }\n\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     *\n     * This implementation will automatically fit the children's bounds into the calculation. Each child's bounds\n     * is limited to its mask's bounds or filterArea, if any is applied.\n     */\n    calculateBounds(): void\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            const child = this.children[i];\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                const maskObject = ((child._mask as MaskData).maskObject || child._mask) as Container;\n\n                maskObject.calculateBounds();\n                this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._bounds.updateID = this._boundsID;\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     *\n     * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()\n     * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.\n     *\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @param skipChildrenUpdate - Setting to `true` will stop re-calculation of children transforms,\n     *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.\n     * @return - The rectangular bounding area.\n     */\n    public getLocalBounds(rect?: Rectangle, skipChildrenUpdate = false): Rectangle\n    {\n        const result = super.getLocalBounds(rect);\n\n        if (!skipChildrenUpdate)\n        {\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                const child = this.children[i];\n\n                if (child.visible)\n                {\n                    child.updateTransform();\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Recalculates the content bounds of this object. This should be overriden to\n     * calculate the bounds of this specific object (not including children).\n     *\n     * @protected\n     */\n    protected _calculateBounds(): void\n    {\n        // FILL IN//\n    }\n\n    /**\n     * Renders this object and its children with culling.\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _renderWithCulling(renderer: Renderer): void\n    {\n        const sourceFrame = renderer.renderTexture.sourceFrame;\n\n        // If the source frame is empty, stop rendering.\n        if (!(sourceFrame.width > 0 && sourceFrame.height > 0))\n        {\n            return;\n        }\n\n        // Render the content of the container only if its bounds intersect with the source frame.\n        // All filters are on the stack at this point, and the filter source frame is bound:\n        // therefore, even if the bounds to non intersect the filter frame, the filter\n        // is still applied and any filter padding that is in the frame is rendered correctly.\n\n        let bounds: Rectangle;\n        let transform: Matrix;\n\n        // If cullArea is set, we use this rectangle instead of the bounds of the object. The cullArea\n        // rectangle must completely contain the container and its children including filter padding.\n        if (this.cullArea)\n        {\n            bounds = this.cullArea;\n            transform = this.worldTransform;\n        }\n        // If the container doesn't override _render, we can skip the bounds calculation and intersection test.\n        else if (this._render !== Container.prototype._render)\n        {\n            bounds = this.getBounds(true);\n        }\n\n        // Render the container if the source frame intersects the bounds.\n        if (bounds && sourceFrame.intersects(bounds, transform))\n        {\n            this._render(renderer);\n        }\n        // If the bounds are defined by cullArea and do not intersect with the source frame, stop rendering.\n        else if (this.cullArea)\n        {\n            return;\n        }\n\n        // Unless cullArea is set, we cannot skip the children if the bounds of the container do not intersect\n        // the source frame, because the children might have filters with nonzero padding, which may intersect\n        // with the source frame while the bounds do not: filter padding is not included in the bounds.\n\n        // If cullArea is not set, render the children with culling temporarily enabled so that they are not rendered\n        // if they are out of frame; otherwise, render the children normally.\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n            const childCullable = child.cullable;\n\n            child.cullable = childCullable || !this.cullArea;\n            child.render(renderer);\n            child.cullable = childCullable;\n        }\n    }\n\n    /**\n     * Renders the object using the WebGL renderer.\n     *\n     * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the\n     * container itself. This `render` method will invoke it, and also invoke the `render` methods of all\n     * children afterward.\n     *\n     * If `renderable` or `visible` is false or if `worldAlpha` is not positive or if `cullable` is true and\n     * the bounds of this object are out of frame, this implementation will entirely skip rendering.\n     * See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,\n     * setting alpha to zero is not recommended for purely skipping rendering.\n     *\n     * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is\n     * advised to employ **culling** to automatically skip rendering objects outside of the current screen.\n     * See [cullable]{@link PIXI.DisplayObject#cullable} and [cullArea]{@link PIXI.DisplayObject#cullArea}.\n     * Other culling methods might be better suited for a large number static objects; see\n     * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and\n     * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull}.\n     *\n     * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or\n     * filtering is applied on a container. This does, however, break batching and can affect performance when\n     * masking and filtering is applied extensively throughout the scene graph.\n     *\n     * @param renderer - The renderer\n     */\n    render(renderer: Renderer): void\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || (this.filters && this.filters.length))\n        {\n            this.renderAdvanced(renderer);\n        }\n        else if (this.cullable)\n        {\n            this._renderWithCulling(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].render(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features.\n     *\n     * @param renderer - The renderer\n     */\n    protected renderAdvanced(renderer: Renderer): void\n    {\n        const filters = this.filters;\n        const mask = this._mask as MaskData;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n        }\n\n        const flush = (filters && this._enabledFilters && this._enabledFilters.length)\n            || (mask && (!mask.isMaskData\n                || (mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE))));\n\n        if (flush)\n        {\n            renderer.batch.flush();\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filter.push(this, this._enabledFilters);\n        }\n\n        if (mask)\n        {\n            renderer.mask.push(this, this._mask);\n        }\n\n        if (this.cullable)\n        {\n            this._renderWithCulling(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].render(renderer);\n            }\n        }\n\n        if (flush)\n        {\n            renderer.batch.flush();\n        }\n\n        if (mask)\n        {\n            renderer.mask.pop(this);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filter.pop();\n        }\n    }\n\n    /**\n     * To be overridden by the subclasses.\n     *\n     * @param renderer - The renderer\n     */\n    protected _render(_renderer: Renderer): void // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     *\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options?: IDestroyOptions|boolean): void\n    {\n        super.destroy();\n\n        this.sortDirty = false;\n\n        const destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n\n    /** The width of the Container, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        return this.scale.x * this.getLocalBounds().width;\n    }\n\n    set width(value: number)\n    {\n        const width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        this._width = value;\n    }\n\n    /** The height of the Container, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        return this.scale.y * this.getLocalBounds().height;\n    }\n\n    set height(value: number)\n    {\n        const height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n}\n\n/**\n * Container default updateTransform, does update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.Container#\n * @method containerUpdateTransform\n */\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n"],"names":["settings","SORTABLE_CHILDREN","Bounds","this","minX","Infinity","minY","maxX","maxY","rect","updateID","prototype","isEmpty","clear","getRectangle","Rectangle","EMPTY","x","y","width","height","addPoint","point","Math","min","max","addPointMatrix","matrix","a","b","c","d","tx","ty","addQuad","vertices","addFrame","transform","x0","y0","x1","y1","addFrameMatrix","worldTransform","addVertexData","vertexData","beginOffset","endOffset","i","addVertices","addVerticesMatrix","padX","padY","rawX","rawY","addBounds","bounds","addBoundsMask","mask","_minX","_minY","_maxX","_maxY","addBoundsMatrix","addBoundsArea","area","pad","paddingX","paddingY","addFramePad","extendStatics","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","create","DisplayObject","_super","_this","tempDisplayObjectParent","Transform","alpha","visible","renderable","cullable","cullArea","parent","worldAlpha","_lastSortedIndex","_zIndex","filterArea","filters","_enabledFilters","_bounds","_localBounds","_boundsID","_boundsRect","_localBoundsRect","_mask","_maskRefCount","_destroyed","isSprite","isMask","mixin","source","keys","length","propertyName","defineProperty","getOwnPropertyDescriptor","get","_recursivePostUpdateTransform","updateTransform","_tempDisplayObjectParent","getBounds","skipUpdate","calculateBounds","getLocalBounds","transformRef","parentRef","worldBounds","worldBoundsID","toGlobal","position","displayObjectUpdateTransform","apply","toLocal","from","applyInverse","setParent","container","addChild","Error","setTransform","scaleX","scaleY","rotation","skewX","skewY","pivotX","pivotY","scale","skew","pivot","destroy","_options","removeChild","emit","removeAllListeners","hitArea","interactive","interactiveChildren","TemporaryDisplayObject","enableTempParent","myParent","disableTempParent","cacheParent","set","value","localTransform","copyFrom","RAD_TO_DEG","DEG_TO_RAD","sortDirty","item","maskObject","EventEmitter","arguments","sortChildren","zIndex","Container","children","sortableChildren","onChildrenChange","_length","_i","child","_parentID","push","addChildAt","index","splice","swapChildren","child2","index1","getChildIndex","index2","indexOf","setChildIndex","currentIndex","removeItems","getChildAt","removeChildAt","removeChildren","beginIndex","endIndex","removed","begin","range","RangeError","sortRequired","j","sort","_calculateBounds","skipChildrenUpdate","result","call","_renderWithCulling","renderer","sourceFrame","renderTexture","_render","intersects","childCullable","render","renderAdvanced","enabled","flush","isMaskData","autoDetect","type","MASK_TYPES","NONE","batch","filter","pop","_renderer","options","destroyChildren","oldChildren","_width","_height","containerUpdateTransform"],"mappings":"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"}